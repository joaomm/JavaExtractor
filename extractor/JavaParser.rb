require "#{ROOT}/model/class_definition"
require "#{ROOT}/model/attribute_definition"
require "#{ROOT}/model/parameter_definition"
require "#{ROOT}/model/local_variable_definition"
require "#{ROOT}/model/method_definition"

# JavaParser (Java.g)
# Generated by ANTLR 3.0.1 on 2010-01-18 12:36:19

require 'JavaLexer'

class JavaParser
	attr_reader :lexer
	
    TOKENS = [
        ["CLASS", 1],
        ["IDENTIFIER", 2],
        ["EXTENDS", 3],
        ["IMPLEMENTS", 4],
        ["NUMBER", 5],
        ["RETURN", 6],
        ["PRIVATE", 7],
        ["PUBLIC", 8],
        ["PROTECTED", 9],
        ["STATIC", 10],
        ["ABSTRACT", 11],
        ["FINAL", 12],
        ["NATIVE", 13],
        ["SYNCHRONIZED", 14],
        ["TRANSIENT", 15],
        ["VOLATILE", 16],
        ["STRICTFP", 17],
        ["ANNOTATION", 18],
        ["NEW", 19],
        ["WS", 20],
        ["SEMICOLON", 21],
        ["LEFT_ANGULAR_BRACKET", 22],
        ["RIGHT_ANGULAR_BRACKET", 23],
        ["COMMA", 24],
        ["ECOMMERCIAL", 25],
        ["LEFT_BRACE", 26],
        ["RIGHT_BRACE", 27],
        ["EQUAL", 28],
        ["LEFT_PARENTESIS", 29],
        ["RIGHT_PARENTESIS", 30],
        ["DOT", 31],
        ["LEFT_SQUARE_BRACKET", 32],
        ["RIGHT_SQUARE_BRACKET", 33],
        ["QUESTION_MARK", 34],
        ["PLUS", 35],
        ["MINUS", 36],
        ["TIMES", 37],
        ["MODULUS", 38],
        ["COLON", 39],
        ["PIPE", 40],
        ["WEDGE", 41],
        ["EXCLATION_MARK", 42],
        ["SLASH", 43],
        ["BACKSLASH", 44],
        ["SINGLE_QUOTES", 45],
        ["DOUBLE_QUOTES", 46],
        ["UNDERLINE", 47],
        ["DOLLAR", 48],
        ["AT", 49],
        ["TILDE", 50],
        ["HASH", 51],
        ["DIGIT", 52],
        ["INITIAL_LETTER", 53],
        ["PARTIAL_LETTER", 54],
        ["'this'", 55],
        ["'\\\\\"'", 56],
        ["'\\\\\\''", 57]
    ].inject({}) { |hash, pair|
        name = pair[0]
        index = pair[1] + 3 # hardcoded for now... no way to get this value from ANTLR

        if name[0] == ?'
            hash[:"T#{index}"] = index
        else
            hash[:"#{name}"] = index
        end

        hash
    }
    
    TOKENS[:EOF] = -1

    def initialize(input)
        if input.respond_to?(:to_str) || input.respond_to?(:read)
            input = JavaLexer.new(input)
        end

		@lexer = input
        @input = TokenStream.new(input)
        @backtracking = 0
        @failed = false


    end

    # 7:1: prog : ( statement )+ ;
    def prog()



        # 8:5: ( statement )+
        # 8:5: ( statement )+
        matchedOnce1 = false
        while true
            alt1 = 2
            # ()+ loopback of 8:5: ( statement )+
            look_ahead1_0 = look_ahead(1)
            if look_ahead1_0 == :CLASS || (TOKENS[look_ahead1_0] >= 10 && TOKENS[look_ahead1_0] <= 20)  
                alt1 = 1
            end
            case alt1
                when 1
                    # 8:5: statement
                    statement()

                else
                    break
            end
            matchedOnce1 = true
        end

        if !matchedOnce1
            raise "Expected at least one match: 8:5: ( statement )+"
        end



    end

    # 11:1: statement : class_definition ;
    def statement()



        # 12:5: class_definition
        class_definition()




    end

    # 15:1: class_definition : modifier[class_def] CLASS ( IDENTIFIER ) ( class_name_parameters[class_def] )? ( inheritance[class_def] )? ( interface[class_def] )? class_body[class_def] ;
    def class_definition()
    	_IDENTIFIER1 = nil




    	    class_def = ClassDefinition.new


        # 19:7: modifier[class_def] CLASS ( IDENTIFIER ) ( class_name_parameters[class_def] )? ( inheritance[class_def] )? ( interface[class_def] )? class_body[class_def]
        modifier(class_def)

        match(:CLASS)
        # 21:8: IDENTIFIER
        _IDENTIFIER1 = @input.look_ahead(1)
        match(:IDENTIFIER)
         class_def.name = _IDENTIFIER1.text 
        # 22:7: ( class_name_parameters[class_def] )?
        alt2 = 2
        # 22:7: ( class_name_parameters[class_def] )?
        look_ahead2_0 = look_ahead(1)

        if look_ahead2_0 == :LEFT_ANGULAR_BRACKET  
            alt2 = 1
        end
        case alt2
            when 1
                # 22:9: class_name_parameters[class_def]
                class_name_parameters(class_def)

        end
        # 23:7: ( inheritance[class_def] )?
        alt3 = 2
        # 23:7: ( inheritance[class_def] )?
        look_ahead3_0 = look_ahead(1)

        if look_ahead3_0 == :EXTENDS  
            alt3 = 1
        end
        case alt3
            when 1
                # 23:8: inheritance[class_def]
                inheritance(class_def)

        end
        # 24:7: ( interface[class_def] )?
        alt4 = 2
        # 24:7: ( interface[class_def] )?
        look_ahead4_0 = look_ahead(1)

        if look_ahead4_0 == :IMPLEMENTS  
            alt4 = 1
        end
        case alt4
            when 1
                # 24:8: interface[class_def]
                interface(class_def)

        end
        class_body(class_def)


                puts class_def.report
              



    end

    # 31:1: class_name_parameters[class_def] : '<' ( class_special_identifier[class_def] )* '>' ;
    def class_name_parameters(class_def)



        # 32:7: '<' ( class_special_identifier[class_def] )* '>'
        match(:LEFT_ANGULAR_BRACKET)
         class_def.name += '<'
        # 33:7: ( class_special_identifier[class_def] )*
        while true
            alt5 = 2
            # ()* loopback of 33:7: ( class_special_identifier[class_def] )*
            look_ahead5_0 = look_ahead(1)
            if look_ahead5_0 == :RIGHT_ANGULAR_BRACKET  
                # ()* loopback of 33:7: ( class_special_identifier[class_def] )*
                look_ahead5_1 = look_ahead(2)
                if look_ahead5_1 == :IDENTIFIER || (TOKENS[look_ahead5_1] >= 25 && TOKENS[look_ahead5_1] <= 28)  
                    alt5 = 1
                elsif look_ahead5_1 == :EXTENDS  
                    # ()* loopback of 33:7: ( class_special_identifier[class_def] )*
                    look_ahead5_3 = look_ahead(3)
                    if look_ahead5_3 == :IDENTIFIER  
                        # ()* loopback of 33:7: ( class_special_identifier[class_def] )*
                        look_ahead5_5 = look_ahead(4)
                        if (TOKENS[look_ahead5_5] >= 5 && TOKENS[look_ahead5_5] <= 6) || (TOKENS[look_ahead5_5] >= 25 && TOKENS[look_ahead5_5] <= 28)  
                            alt5 = 1
                        end
                    elsif look_ahead5_3 == :EXTENDS || (TOKENS[look_ahead5_3] >= 25 && TOKENS[look_ahead5_3] <= 28)  
                        alt5 = 1
                    end
                end
            elsif (TOKENS[look_ahead5_0] >= 5 && TOKENS[look_ahead5_0] <= 6) || look_ahead5_0 == :LEFT_ANGULAR_BRACKET || (TOKENS[look_ahead5_0] >= 27 && TOKENS[look_ahead5_0] <= 28)  
                alt5 = 1
            end
            case alt5
                when 1
                    # 33:9: class_special_identifier[class_def]
                    class_special_identifier(class_def)

                else
                    break
            end
        end
        match(:RIGHT_ANGULAR_BRACKET)
         class_def.name += '>'



    end

    # 37:1: class_special_identifier[class_def] : ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS );
    def class_special_identifier(class_def)
    	_IDENTIFIER2 = nil
    	_EXTENDS3 = nil




        # 38:5: ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS )
        alt6 = 6
        # 37:1: class_special_identifier[class_def] : ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS );
        case look_ahead(1)
            when :IDENTIFIER
                alt6 = 1
            when :COMMA
                alt6 = 2
            when :ECOMMERCIAL
                alt6 = 3
            when :LEFT_ANGULAR_BRACKET
                alt6 = 4
            when :RIGHT_ANGULAR_BRACKET
                alt6 = 5
            when :EXTENDS
                alt6 = 6
            else
                raise "Expected: 37:1: class_special_identifier[class_def] : ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS );"

        end
        case alt6
            when 1
                # 38:7: IDENTIFIER
                _IDENTIFIER2 = @input.look_ahead(1)
                match(:IDENTIFIER)
                 class_def.name += _IDENTIFIER2.text
            when 2
                # 39:7: ','
                match(:COMMA)
                 class_def.name += ", "
            when 3
                # 40:7: '&'
                match(:ECOMMERCIAL)
                 class_def.name += " & "
            when 4
                # 41:7: '<'
                match(:LEFT_ANGULAR_BRACKET)
                 class_def.name += '<'
            when 5
                # 42:7: '>'
                match(:RIGHT_ANGULAR_BRACKET)
                 class_def.name += '>'
            when 6
                # 43:7: EXTENDS
                _EXTENDS3 = @input.look_ahead(1)
                match(:EXTENDS)
                 class_def.name += " #{_EXTENDS3.text} "
        end



    end

    # 46:1: inheritance[class_def] : EXTENDS IDENTIFIER ;
    def inheritance(class_def)
    	_IDENTIFIER4 = nil




        # 47:7: EXTENDS IDENTIFIER
        match(:EXTENDS)
        _IDENTIFIER4 = @input.look_ahead(1)
        match(:IDENTIFIER)
         class_def.add_parent(_IDENTIFIER4.text)



    end

    # 50:1: interface[class_def] : IMPLEMENTS interface_name[class_def] ( ',' interface_name[class_def] )* ;
    def interface(class_def)



        # 51:7: IMPLEMENTS interface_name[class_def] ( ',' interface_name[class_def] )*
        match(:IMPLEMENTS)
        interface_name(class_def)

        # 51:44: ( ',' interface_name[class_def] )*
        while true
            alt7 = 2
            # ()* loopback of 51:44: ( ',' interface_name[class_def] )*
            look_ahead7_0 = look_ahead(1)
            if look_ahead7_0 == :COMMA  
                alt7 = 1
            end
            case alt7
                when 1
                    # 51:45: ',' interface_name[class_def]
                    match(:COMMA)
                    interface_name(class_def)

                else
                    break
            end
        end



    end

    # 54:1: interface_name[class_def] : IDENTIFIER ;
    def interface_name(class_def)
    	_IDENTIFIER5 = nil




        # 55:7: IDENTIFIER
        _IDENTIFIER5 = @input.look_ahead(1)
        match(:IDENTIFIER)
         class_def.add_interface(_IDENTIFIER5.text) 



    end

    # 59:1: class_body[class_def] : '{' ( member_definition[class_def] )* '}' ;
    def class_body(class_def)



        # 61:5: '{' ( member_definition[class_def] )* '}'
        match(:LEFT_BRACE)
        # 61:9: ( member_definition[class_def] )*
        while true
            alt8 = 2
            # ()* loopback of 61:9: ( member_definition[class_def] )*
            look_ahead8_0 = look_ahead(1)
            if look_ahead8_0 == :IDENTIFIER || (TOKENS[look_ahead8_0] >= 10 && TOKENS[look_ahead8_0] <= 20)  
                alt8 = 1
            end
            case alt8
                when 1
                    # 61:9: member_definition[class_def]
                    member_definition(class_def)

                else
                    break
            end
        end
        match(:RIGHT_BRACE)



    end

    # 64:1: member_definition[class_def] : ( attribute_definition[class_def] | method_definition[class_def] );
    def member_definition(class_def)



        # 65:5: ( attribute_definition[class_def] | method_definition[class_def] )
        alt9 = 2
        alt9 = DFA9.predict(self, @input)
        case alt9
            when 1
                # 65:7: attribute_definition[class_def]
                attribute_definition(class_def)

            when 2
                # 66:7: method_definition[class_def]
                method_definition(class_def)

        end



    end

    # 69:1: attribute_definition[class_def] : modifier[attribute] type[attribute] attributes_list[attribute, attributes] ';' ;
    def attribute_definition(class_def)



    	    attribute = AttributeDefinition.new
    	    attributes = []


        # 75:5: modifier[attribute] type[attribute] attributes_list[attribute, attributes] ';'
        modifier(attribute)

        type(attribute)

        attributes_list(attribute,  attributes)

        match(:SEMICOLON)

                attributes.each do |attribute|
                    class_def.add_member(attribute)
                end
            



    end

    # 82:1: attributes_list[attribute, attributes] : attribute_declarator[attribute, attributes] ( ',' attribute_declarator[attribute, attributes] )* ;
    def attributes_list(attribute, attributes)



        # 83:7: attribute_declarator[attribute, attributes] ( ',' attribute_declarator[attribute, attributes] )*
        attribute_declarator(attribute,  attributes)

        # 84:7: ( ',' attribute_declarator[attribute, attributes] )*
        while true
            alt10 = 2
            # ()* loopback of 84:7: ( ',' attribute_declarator[attribute, attributes] )*
            look_ahead10_0 = look_ahead(1)
            if look_ahead10_0 == :COMMA  
                alt10 = 1
            end
            case alt10
                when 1
                    # 84:9: ',' attribute_declarator[attribute, attributes]
                    match(:COMMA)
                    attribute_declarator(attribute,  attributes)

                else
                    break
            end
        end



    end

    # 87:1: attribute_declarator[attribute_to_copy_from, attributes] : IDENTIFIER ( array_brackets[new_attribute] )* ( initialization )? ;
    def attribute_declarator(attribute_to_copy_from, attributes)
    	_IDENTIFIER6 = nil




        # 88:7: IDENTIFIER ( array_brackets[new_attribute] )* ( initialization )?
        _IDENTIFIER6 = @input.look_ahead(1)
        match(:IDENTIFIER)

                new_attribute = AttributeDefinition.new
                new_attribute.name = _IDENTIFIER6.text
                new_attribute.line = _IDENTIFIER6.line
                new_attribute.type = attribute_to_copy_from.type
                new_attribute.copy_modifiers_from(attribute_to_copy_from)
                attributes << new_attribute
              
        # 96:7: ( array_brackets[new_attribute] )*
        while true
            alt11 = 2
            # ()* loopback of 96:7: ( array_brackets[new_attribute] )*
            look_ahead11_0 = look_ahead(1)
            if look_ahead11_0 == :LEFT_SQUARE_BRACKET  
                alt11 = 1
            end
            case alt11
                when 1
                    # 96:9: array_brackets[new_attribute]
                    array_brackets(new_attribute)

                else
                    break
            end
        end
        # 97:7: ( initialization )?
        alt12 = 2
        # 97:7: ( initialization )?
        look_ahead12_0 = look_ahead(1)

        if look_ahead12_0 == :EQUAL  
            alt12 = 1
        end
        case alt12
            when 1
                # 97:7: initialization
                initialization()

        end



    end

    # 100:1: initialization : '=' initializer ;
    def initialization()



        # 101:7: '=' initializer
        match(:EQUAL)
        initializer()




    end

    # 104:1: initializer : ( array_initializer | initializer_expression | 'new' IDENTIFIER '(' ')' );
    def initializer()



        # 105:5: ( array_initializer | initializer_expression | 'new' IDENTIFIER '(' ')' )
        alt13 = 3
        # 104:1: initializer : ( array_initializer | initializer_expression | 'new' IDENTIFIER '(' ')' );
        case look_ahead(1)
            when :LEFT_BRACE
                alt13 = 1
            when :NUMBER
                alt13 = 2
            when :NEW
                alt13 = 3
            else
                raise "Expected: 104:1: initializer : ( array_initializer | initializer_expression | 'new' IDENTIFIER '(' ')' );"

        end
        case alt13
            when 1
                # 105:7: array_initializer
                array_initializer()

            when 2
                # 106:7: initializer_expression
                initializer_expression()

            when 3
                # 107:7: 'new' IDENTIFIER '(' ')'
                match(:NEW)
                match(:IDENTIFIER)
                match(:LEFT_PARENTESIS)
                match(:RIGHT_PARENTESIS)
        end



    end

    # 110:1: array_initializer : '{' ( initializer ( ',' initializer )* )? '}' ;
    def array_initializer()



        # 111:7: '{' ( initializer ( ',' initializer )* )? '}'
        match(:LEFT_BRACE)
        # 111:11: ( initializer ( ',' initializer )* )?
        alt15 = 2
        # 111:11: ( initializer ( ',' initializer )* )?
        look_ahead15_0 = look_ahead(1)

        if look_ahead15_0 == :NUMBER || look_ahead15_0 == :NEW || look_ahead15_0 == :LEFT_BRACE  
            alt15 = 1
        end
        case alt15
            when 1
                # 111:12: initializer ( ',' initializer )*
                initializer()

                # 111:24: ( ',' initializer )*
                while true
                    alt14 = 2
                    # ()* loopback of 111:24: ( ',' initializer )*
                    look_ahead14_0 = look_ahead(1)
                    if look_ahead14_0 == :COMMA  
                        alt14 = 1
                    end
                    case alt14
                        when 1
                            # 111:25: ',' initializer
                            match(:COMMA)
                            initializer()

                        else
                            break
                    end
                end
        end
        match(:RIGHT_BRACE)



    end

    # 114:1: initializer_expression : NUMBER ;
    def initializer_expression()



        # 115:7: NUMBER
        match(:NUMBER)



    end

    # 118:1: method_definition[class_def] : modifier[method] ( type[method] )? IDENTIFIER parameters[method] method_body[method] ;
    def method_definition(class_def)
    	_IDENTIFIER7 = nil




    	    method = MethodDefinition.new


        # 123:5: modifier[method] ( type[method] )? IDENTIFIER parameters[method] method_body[method]
        modifier(method)

        # 123:22: ( type[method] )?
        alt16 = 2
        # 123:22: ( type[method] )?
        look_ahead16_0 = look_ahead(1)

        if look_ahead16_0 == :IDENTIFIER  
            # 123:22: ( type[method] )?
            look_ahead16_1 = look_ahead(2)

            if look_ahead16_1 == :IDENTIFIER || look_ahead16_1 == :LEFT_ANGULAR_BRACKET || (TOKENS[look_ahead16_1] >= 34 && TOKENS[look_ahead16_1] <= 35)  
                alt16 = 1
            end
        end
        case alt16
            when 1
                # 123:23: type[method]
                type(method)

        end
        _IDENTIFIER7 = @input.look_ahead(1)
        match(:IDENTIFIER)
        parameters(method)

        method_body(method)


                method.name = _IDENTIFIER7.text
                method.line = _IDENTIFIER7.line
                class_def.add_member(method)
            



    end

    # 130:1: method_body[method] : '{' ( body_statement[method] )* '}' ;
    def method_body(method)



        # 132:5: '{' ( body_statement[method] )* '}'
        match(:LEFT_BRACE)
        # 133:8: ( body_statement[method] )*
        while true
            alt17 = 2
            # ()* loopback of 133:8: ( body_statement[method] )*
            look_ahead17_0 = look_ahead(1)
            if look_ahead17_0 == :IDENTIFIER || look_ahead17_0 == :RETURN || look_ahead17_0 == :FINAL || look_ahead17_0 == :ANNOTATION || look_ahead17_0 == :T58  
                alt17 = 1
            end
            case alt17
                when 1
                    # 133:10: body_statement[method]
                    body_statement(method)

                else
                    break
            end
        end
        match(:RIGHT_BRACE)



    end

    # 137:1: body_statement[method] : ( local_variable_declaration[method] | return_expression[method] | assign_operation[method] | method_call[method] );
    def body_statement(method)



        # 138:5: ( local_variable_declaration[method] | return_expression[method] | assign_operation[method] | method_call[method] )
        alt18 = 4
        alt18 = DFA18.predict(self, @input)
        case alt18
            when 1
                # 138:7: local_variable_declaration[method]
                local_variable_declaration(method)

            when 2
                # 139:7: return_expression[method]
                return_expression(method)

            when 3
                # 140:7: assign_operation[method]
                assign_operation(method)

            when 4
                # 141:7: method_call[method]
                method_call(method)

        end



    end

    # 144:1: local_variable_declaration[method] : variable_modifier type[dummy_variable] local_variable_list[dummy_variable, local_variables, method] ';' ;
    def local_variable_declaration(method)



    	    dummy_variable = LocalVariableDefinition.new
    	    local_variables = []


        # 149:7: variable_modifier type[dummy_variable] local_variable_list[dummy_variable, local_variables, method] ';'
        variable_modifier()

        type(dummy_variable)

        local_variable_list(dummy_variable,  local_variables,  method)

        match(:SEMICOLON)

                local_variables.each do |local_variable|
                    method.add_local_variable(local_variable)
                end
                local_variables.each do |local_variable|
                    method.add_use_of(local_variable.name, local_variable.line) if local_variable.was_initialized?
                end
            



    end

    # 160:1: local_variable_list[dummy_variable, local_variables, method] : local_variable_declarator[dummy_variable, local_variables, method] ( ',' local_variable_declarator[dummy_variable, local_variables, method] )* ;
    def local_variable_list(dummy_variable, local_variables, method)



        # 161:7: local_variable_declarator[dummy_variable, local_variables, method] ( ',' local_variable_declarator[dummy_variable, local_variables, method] )*
        local_variable_declarator(dummy_variable,  local_variables,  method)

        # 162:7: ( ',' local_variable_declarator[dummy_variable, local_variables, method] )*
        while true
            alt19 = 2
            # ()* loopback of 162:7: ( ',' local_variable_declarator[dummy_variable, local_variables, method] )*
            look_ahead19_0 = look_ahead(1)
            if look_ahead19_0 == :COMMA  
                alt19 = 1
            end
            case alt19
                when 1
                    # 162:8: ',' local_variable_declarator[dummy_variable, local_variables, method]
                    match(:COMMA)
                    local_variable_declarator(dummy_variable,  local_variables,  method)

                else
                    break
            end
        end



    end

    # 165:1: local_variable_declarator[dummy_variable, local_variables, method] : IDENTIFIER ( '[' ']' )* ( local_variable_initialization[method] )? ;
    def local_variable_declarator(dummy_variable, local_variables, method)
    	_IDENTIFIER8 = nil




    	    local_variable = LocalVariableDefinition.new


        # 169:7: IDENTIFIER ( '[' ']' )* ( local_variable_initialization[method] )?
        _IDENTIFIER8 = @input.look_ahead(1)
        match(:IDENTIFIER)

                local_variable.name = _IDENTIFIER8.text
                local_variable.line = _IDENTIFIER8.line
                local_variable.type = dummy_variable.type
              
        # 174:7: ( '[' ']' )*
        while true
            alt20 = 2
            # ()* loopback of 174:7: ( '[' ']' )*
            look_ahead20_0 = look_ahead(1)
            if look_ahead20_0 == :LEFT_SQUARE_BRACKET  
                alt20 = 1
            end
            case alt20
                when 1
                    # 174:8: '[' ']'
                    match(:LEFT_SQUARE_BRACKET)
                    match(:RIGHT_SQUARE_BRACKET)
                     local_variable.type << "[]" 
                else
                    break
            end
        end
        # 175:7: ( local_variable_initialization[method] )?
        alt21 = 2
        # 175:7: ( local_variable_initialization[method] )?
        look_ahead21_0 = look_ahead(1)

        if look_ahead21_0 == :EQUAL  
            alt21 = 1
        end
        case alt21
            when 1
                # 175:8: local_variable_initialization[method]
                local_variable_initialization(method)

        end
         local_variable.was_initialized 

                local_variables << local_variable
              



    end

    # 181:1: local_variable_initialization[method] : '=' ( constructor_call[method] | ( method_expression[method] )* ) ;
    def local_variable_initialization(method)



        # 182:7: '=' ( constructor_call[method] | ( method_expression[method] )* )
        match(:EQUAL)
        # 182:11: ( constructor_call[method] | ( method_expression[method] )* )
        alt23 = 2
        # 182:11: ( constructor_call[method] | ( method_expression[method] )* )
        look_ahead23_0 = look_ahead(1)
        if look_ahead23_0 == :NEW  
            alt23 = 1
        elsif look_ahead23_0 == :IDENTIFIER || look_ahead23_0 == :NUMBER || (TOKENS[look_ahead23_0] >= 24 && TOKENS[look_ahead23_0] <= 28) || (TOKENS[look_ahead23_0] >= 31 && TOKENS[look_ahead23_0] <= 32) || (TOKENS[look_ahead23_0] >= 34 && TOKENS[look_ahead23_0] <= 46) || (TOKENS[look_ahead23_0] >= 48 && TOKENS[look_ahead23_0] <= 49)  
            alt23 = 2
        else
            raise "Expected: 182:11: ( constructor_call[method] | ( method_expression[method] )* )"
        end
        case alt23
            when 1
                # 182:12: constructor_call[method]
                constructor_call(method)

            when 2
                # 182:39: ( method_expression[method] )*
                # 182:39: ( method_expression[method] )*
                while true
                    alt22 = 2
                    # ()* loopback of 182:39: ( method_expression[method] )*
                    look_ahead22_0 = look_ahead(1)
                    if look_ahead22_0 == :IDENTIFIER || look_ahead22_0 == :NUMBER || (TOKENS[look_ahead22_0] >= 25 && TOKENS[look_ahead22_0] <= 26) || look_ahead22_0 == :ECOMMERCIAL || (TOKENS[look_ahead22_0] >= 31 && TOKENS[look_ahead22_0] <= 32) || (TOKENS[look_ahead22_0] >= 34 && TOKENS[look_ahead22_0] <= 46) || (TOKENS[look_ahead22_0] >= 48 && TOKENS[look_ahead22_0] <= 49)  
                        alt22 = 1
                    end
                    case alt22
                        when 1
                            # 182:39: method_expression[method]
                            method_expression(method)

                        else
                            break
                    end
                end
        end



    end

    # 185:1: constructor_call[method] : 'new' IDENTIFIER '(' ( method_expression[method] )* ')' ;
    def constructor_call(method)
    	_IDENTIFIER9 = nil




        # 186:7: 'new' IDENTIFIER '(' ( method_expression[method] )* ')'
        match(:NEW)
        _IDENTIFIER9 = @input.look_ahead(1)
        match(:IDENTIFIER)
        match(:LEFT_PARENTESIS)
        # 186:28: ( method_expression[method] )*
        while true
            alt24 = 2
            # ()* loopback of 186:28: ( method_expression[method] )*
            look_ahead24_0 = look_ahead(1)
            if look_ahead24_0 == :IDENTIFIER || look_ahead24_0 == :NUMBER || (TOKENS[look_ahead24_0] >= 25 && TOKENS[look_ahead24_0] <= 26) || look_ahead24_0 == :ECOMMERCIAL || (TOKENS[look_ahead24_0] >= 31 && TOKENS[look_ahead24_0] <= 32) || (TOKENS[look_ahead24_0] >= 34 && TOKENS[look_ahead24_0] <= 46) || (TOKENS[look_ahead24_0] >= 48 && TOKENS[look_ahead24_0] <= 49)  
                alt24 = 1
            end
            case alt24
                when 1
                    # 186:28: method_expression[method]
                    method_expression(method)

                else
                    break
            end
        end
        match(:RIGHT_PARENTESIS)

               method.add_method_call( "#{_IDENTIFIER9.text} constructor", _IDENTIFIER9.line)
            



    end

    # 192:1: return_expression[method] : RETURN ( method_expression[method] )* ';' ;
    def return_expression(method)



        # 193:7: RETURN ( method_expression[method] )* ';'
        match(:RETURN)
        # 193:14: ( method_expression[method] )*
        while true
            alt25 = 2
            # ()* loopback of 193:14: ( method_expression[method] )*
            look_ahead25_0 = look_ahead(1)
            if look_ahead25_0 == :IDENTIFIER || look_ahead25_0 == :NUMBER || (TOKENS[look_ahead25_0] >= 25 && TOKENS[look_ahead25_0] <= 26) || look_ahead25_0 == :ECOMMERCIAL || (TOKENS[look_ahead25_0] >= 31 && TOKENS[look_ahead25_0] <= 32) || (TOKENS[look_ahead25_0] >= 34 && TOKENS[look_ahead25_0] <= 46) || (TOKENS[look_ahead25_0] >= 48 && TOKENS[look_ahead25_0] <= 49)  
                alt25 = 1
            end
            case alt25
                when 1
                    # 193:16: method_expression[method]
                    method_expression(method)

                else
                    break
            end
        end
        match(:SEMICOLON)



    end

    # 196:1: method_call[method] : called_method_name[method] '(' ( arguments[method] )* ')' ';' ;
    def method_call(method)



        # 197:7: called_method_name[method] '(' ( arguments[method] )* ')' ';'
        called_method_name(method)

        match(:LEFT_PARENTESIS)
        # 197:38: ( arguments[method] )*
        while true
            alt26 = 2
            # ()* loopback of 197:38: ( arguments[method] )*
            look_ahead26_0 = look_ahead(1)
            if look_ahead26_0 == :IDENTIFIER || look_ahead26_0 == :NUMBER || (TOKENS[look_ahead26_0] >= 25 && TOKENS[look_ahead26_0] <= 26) || look_ahead26_0 == :ECOMMERCIAL || (TOKENS[look_ahead26_0] >= 31 && TOKENS[look_ahead26_0] <= 32) || (TOKENS[look_ahead26_0] >= 34 && TOKENS[look_ahead26_0] <= 46) || (TOKENS[look_ahead26_0] >= 48 && TOKENS[look_ahead26_0] <= 49) || look_ahead26_0 == :T58  
                alt26 = 1
            end
            case alt26
                when 1
                    # 197:38: arguments[method]
                    arguments(method)

                else
                    break
            end
        end
        match(:RIGHT_PARENTESIS)
        match(:SEMICOLON)



    end

    # 200:1: called_method_name[method] : ( 'this' '.' )? IDENTIFIER ( fragment_of_called_method_name[method_name] )* ;
    def called_method_name(method)
    	_IDENTIFIER10 = nil




    	    method_name = ""


        # 204:7: ( 'this' '.' )? IDENTIFIER ( fragment_of_called_method_name[method_name] )*
        # 204:7: ( 'this' '.' )?
        alt27 = 2
        # 204:7: ( 'this' '.' )?
        look_ahead27_0 = look_ahead(1)

        if look_ahead27_0 == :T58  
            alt27 = 1
        end
        case alt27
            when 1
                # 204:9: 'this' '.'
                match(:T58)
                match(:DOT)
        end
        _IDENTIFIER10 = @input.look_ahead(1)
        match(:IDENTIFIER)
         method_name << _IDENTIFIER10.text 
        # 206:7: ( fragment_of_called_method_name[method_name] )*
        while true
            alt28 = 2
            # ()* loopback of 206:7: ( fragment_of_called_method_name[method_name] )*
            look_ahead28_0 = look_ahead(1)
            if look_ahead28_0 == :DOT  
                alt28 = 1
            end
            case alt28
                when 1
                    # 206:7: fragment_of_called_method_name[method_name]
                    fragment_of_called_method_name(method_name)

                else
                    break
            end
        end
         method.add_method_call(method_name, _IDENTIFIER10.line) 



    end

    # 210:1: arguments[method] : first_argument[method] ( other_arguments[method] )* ;
    def arguments(method)



        # 211:7: first_argument[method] ( other_arguments[method] )*
        first_argument(method)

        # 211:30: ( other_arguments[method] )*
        while true
            alt29 = 2
            # ()* loopback of 211:30: ( other_arguments[method] )*
            look_ahead29_0 = look_ahead(1)
            if look_ahead29_0 == :COMMA  
                alt29 = 1
            end
            case alt29
                when 1
                    # 211:32: other_arguments[method]
                    other_arguments(method)

                else
                    break
            end
        end



    end

    # 214:1: first_argument[method] : argument[method] ;
    def first_argument(method)



        # 215:7: argument[method]
        argument(method)




    end

    # 218:1: other_arguments[method] : ',' argument[method] ;
    def other_arguments(method)



        # 219:7: ',' argument[method]
        match(:COMMA)
        argument(method)




    end

    # 222:1: argument[method] : ( ( 'this' '.' )? ( IDENTIFIER ) | any_expression[method] );
    def argument(method)
    	_IDENTIFIER11 = nil




    	    variable_name = ""


        # 226:5: ( ( 'this' '.' )? ( IDENTIFIER ) | any_expression[method] )
        alt31 = 2
        # 222:1: argument[method] : ( ( 'this' '.' )? ( IDENTIFIER ) | any_expression[method] );
        look_ahead31_0 = look_ahead(1)
        if look_ahead31_0 == :IDENTIFIER || look_ahead31_0 == :T58  
            alt31 = 1
        elsif look_ahead31_0 == :NUMBER || (TOKENS[look_ahead31_0] >= 25 && TOKENS[look_ahead31_0] <= 26) || look_ahead31_0 == :ECOMMERCIAL || (TOKENS[look_ahead31_0] >= 31 && TOKENS[look_ahead31_0] <= 32) || (TOKENS[look_ahead31_0] >= 34 && TOKENS[look_ahead31_0] <= 46) || (TOKENS[look_ahead31_0] >= 48 && TOKENS[look_ahead31_0] <= 49)  
            alt31 = 2
        else
            raise "Expected: 222:1: argument[method] : ( ( 'this' '.' )? ( IDENTIFIER ) | any_expression[method] );"
        end
        case alt31
            when 1
                # 226:7: ( 'this' '.' )? ( IDENTIFIER )
                # 226:7: ( 'this' '.' )?
                alt30 = 2
                # 226:7: ( 'this' '.' )?
                look_ahead30_0 = look_ahead(1)

                if look_ahead30_0 == :T58  
                    alt30 = 1
                end
                case alt30
                    when 1
                        # 226:9: 'this' '.'
                        match(:T58)
                        match(:DOT)
                         variable_name << "this." 
                end
                # 227:9: IDENTIFIER
                _IDENTIFIER11 = @input.look_ahead(1)
                match(:IDENTIFIER)

                        variable_name << _IDENTIFIER11.text
                        method.add_use_of(variable_name, _IDENTIFIER11.line)
                      
            when 2
                # 231:7: any_expression[method]
                any_expression(method)

        end



    end

    # 234:1: fragment_of_called_method_name[method_name] : '.' IDENTIFIER ;
    def fragment_of_called_method_name(method_name)
    	_IDENTIFIER12 = nil




        # 235:7: '.' IDENTIFIER
        match(:DOT)
        _IDENTIFIER12 = @input.look_ahead(1)
        match(:IDENTIFIER)
         method_name << ".#{_IDENTIFIER12.text}"



    end

    # 238:1: assign_operation[method] : variable_name[method] assign_operator ( method_expression[method] )* ';' ;
    def assign_operation(method)



        # 239:7: variable_name[method] assign_operator ( method_expression[method] )* ';'
        variable_name(method)

        assign_operator()

        # 239:45: ( method_expression[method] )*
        while true
            alt32 = 2
            # ()* loopback of 239:45: ( method_expression[method] )*
            look_ahead32_0 = look_ahead(1)
            if look_ahead32_0 == :IDENTIFIER || look_ahead32_0 == :NUMBER || (TOKENS[look_ahead32_0] >= 25 && TOKENS[look_ahead32_0] <= 26) || look_ahead32_0 == :ECOMMERCIAL || (TOKENS[look_ahead32_0] >= 31 && TOKENS[look_ahead32_0] <= 32) || (TOKENS[look_ahead32_0] >= 34 && TOKENS[look_ahead32_0] <= 46) || (TOKENS[look_ahead32_0] >= 48 && TOKENS[look_ahead32_0] <= 49)  
                alt32 = 1
            end
            case alt32
                when 1
                    # 239:47: method_expression[method]
                    method_expression(method)

                else
                    break
            end
        end
        match(:SEMICOLON)



    end

    # 242:1: variable_name[method] : ( 'this' '.' )? IDENTIFIER ;
    def variable_name(method)
    	_IDENTIFIER13 = nil




    	  name = ""


        # 246:7: ( 'this' '.' )? IDENTIFIER
        # 246:7: ( 'this' '.' )?
        alt33 = 2
        # 246:7: ( 'this' '.' )?
        look_ahead33_0 = look_ahead(1)

        if look_ahead33_0 == :T58  
            alt33 = 1
        end
        case alt33
            when 1
                # 246:9: 'this' '.'
                match(:T58)
                match(:DOT)
                 name << "this."
        end
        _IDENTIFIER13 = @input.look_ahead(1)
        match(:IDENTIFIER)

                name << _IDENTIFIER13.text
                method.add_use_of(name, _IDENTIFIER13.line)
            



    end

    # 252:1: method_expression[method] : ( IDENTIFIER | any_expression[method] );
    def method_expression(method)
    	_IDENTIFIER14 = nil




        # 253:5: ( IDENTIFIER | any_expression[method] )
        alt34 = 2
        # 252:1: method_expression[method] : ( IDENTIFIER | any_expression[method] );
        look_ahead34_0 = look_ahead(1)
        if look_ahead34_0 == :IDENTIFIER  
            alt34 = 1
        elsif look_ahead34_0 == :NUMBER || (TOKENS[look_ahead34_0] >= 25 && TOKENS[look_ahead34_0] <= 26) || look_ahead34_0 == :ECOMMERCIAL || (TOKENS[look_ahead34_0] >= 31 && TOKENS[look_ahead34_0] <= 32) || (TOKENS[look_ahead34_0] >= 34 && TOKENS[look_ahead34_0] <= 46) || (TOKENS[look_ahead34_0] >= 48 && TOKENS[look_ahead34_0] <= 49)  
            alt34 = 2
        else
            raise "Expected: 252:1: method_expression[method] : ( IDENTIFIER | any_expression[method] );"
        end
        case alt34
            when 1
                # 253:7: IDENTIFIER
                _IDENTIFIER14 = @input.look_ahead(1)
                match(:IDENTIFIER)
                 method.add_use_of(_IDENTIFIER14.text, _IDENTIFIER14.line) 
            when 2
                # 254:7: any_expression[method]
                any_expression(method)

        end



    end

    # 257:1: any_expression[method] : ( '(' ( method_expression[method] )* ')' | NUMBER | expression_operator | double_quoted_expression | single_quoted_expression );
    def any_expression(method)



        # 258:5: ( '(' ( method_expression[method] )* ')' | NUMBER | expression_operator | double_quoted_expression | single_quoted_expression )
        alt36 = 5
        # 257:1: any_expression[method] : ( '(' ( method_expression[method] )* ')' | NUMBER | expression_operator | double_quoted_expression | single_quoted_expression );
        case look_ahead(1)
            when :LEFT_PARENTESIS
                alt36 = 1
            when :NUMBER
                alt36 = 2
            when :LEFT_ANGULAR_BRACKET,:RIGHT_ANGULAR_BRACKET,:ECOMMERCIAL,:EQUAL,:DOT,:LEFT_SQUARE_BRACKET,:RIGHT_SQUARE_BRACKET,:QUESTION_MARK,:PLUS,:MINUS,:TIMES,:MODULUS,:COLON,:PIPE,:WEDGE,:EXCLATION_MARK,:SLASH
                alt36 = 3
            when :DOUBLE_QUOTES
                alt36 = 4
            when :SINGLE_QUOTES
                alt36 = 5
            else
                raise "Expected: 257:1: any_expression[method] : ( '(' ( method_expression[method] )* ')' | NUMBER | expression_operator | double_quoted_expression | single_quoted_expression );"

        end
        case alt36
            when 1
                # 258:7: '(' ( method_expression[method] )* ')'
                match(:LEFT_PARENTESIS)
                # 258:11: ( method_expression[method] )*
                while true
                    alt35 = 2
                    # ()* loopback of 258:11: ( method_expression[method] )*
                    look_ahead35_0 = look_ahead(1)
                    if look_ahead35_0 == :IDENTIFIER || look_ahead35_0 == :NUMBER || (TOKENS[look_ahead35_0] >= 25 && TOKENS[look_ahead35_0] <= 26) || look_ahead35_0 == :ECOMMERCIAL || (TOKENS[look_ahead35_0] >= 31 && TOKENS[look_ahead35_0] <= 32) || (TOKENS[look_ahead35_0] >= 34 && TOKENS[look_ahead35_0] <= 46) || (TOKENS[look_ahead35_0] >= 48 && TOKENS[look_ahead35_0] <= 49)  
                        alt35 = 1
                    end
                    case alt35
                        when 1
                            # 258:13: method_expression[method]
                            method_expression(method)

                        else
                            break
                    end
                end
                match(:RIGHT_PARENTESIS)
            when 2
                # 259:7: NUMBER
                match(:NUMBER)
            when 3
                # 260:7: expression_operator
                expression_operator()

            when 4
                # 261:7: double_quoted_expression
                double_quoted_expression()

            when 5
                # 262:7: single_quoted_expression
                single_quoted_expression()

        end



    end

    # 265:1: double_quoted_expression : '\"' ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\\'' )* '\"' ;
    def double_quoted_expression()



        # 266:7: '\"' ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\\'' )* '\"'
        match(:DOUBLE_QUOTES)
        # 266:11: ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\\'' )*
        while true
            alt37 = 6
            # ()* loopback of 266:11: ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\\'' )*
            case look_ahead(1)
                when :IDENTIFIER
                    alt37 = 1
                when :NUMBER
                    alt37 = 2
                when :LEFT_ANGULAR_BRACKET,:RIGHT_ANGULAR_BRACKET,:ECOMMERCIAL,:EQUAL,:DOT,:LEFT_SQUARE_BRACKET,:RIGHT_SQUARE_BRACKET,:QUESTION_MARK,:PLUS,:MINUS,:TIMES,:MODULUS,:COLON,:PIPE,:WEDGE,:EXCLATION_MARK,:SLASH
                    alt37 = 3
                when :SEMICOLON,:COMMA,:LEFT_BRACE,:RIGHT_BRACE,:LEFT_PARENTESIS,:RIGHT_PARENTESIS,:BACKSLASH,:DOLLAR,:AT,:TILDE,:HASH,:T59,:T60
                    alt37 = 4
                when :SINGLE_QUOTES
                    alt37 = 5
            end
            case alt37
                when 1
                    # 266:12: IDENTIFIER
                    match(:IDENTIFIER)
                when 2
                    # 266:25: NUMBER
                    match(:NUMBER)
                when 3
                    # 266:34: expression_operator
                    expression_operator()

                when 4
                    # 266:56: quoted_operator
                    quoted_operator()

                when 5
                    # 266:74: '\\''
                    match(:SINGLE_QUOTES)
                else
                    break
            end
        end
        match(:DOUBLE_QUOTES)



    end

    # 269:1: single_quoted_expression : '\\'' ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\"' )* '\\'' ;
    def single_quoted_expression()



        # 270:7: '\\'' ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\"' )* '\\''
        match(:SINGLE_QUOTES)
        # 270:12: ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\"' )*
        while true
            alt38 = 6
            # ()* loopback of 270:12: ( IDENTIFIER | NUMBER | expression_operator | quoted_operator | '\"' )*
            case look_ahead(1)
                when :IDENTIFIER
                    alt38 = 1
                when :NUMBER
                    alt38 = 2
                when :LEFT_ANGULAR_BRACKET,:RIGHT_ANGULAR_BRACKET,:ECOMMERCIAL,:EQUAL,:DOT,:LEFT_SQUARE_BRACKET,:RIGHT_SQUARE_BRACKET,:QUESTION_MARK,:PLUS,:MINUS,:TIMES,:MODULUS,:COLON,:PIPE,:WEDGE,:EXCLATION_MARK,:SLASH
                    alt38 = 3
                when :SEMICOLON,:COMMA,:LEFT_BRACE,:RIGHT_BRACE,:LEFT_PARENTESIS,:RIGHT_PARENTESIS,:BACKSLASH,:DOLLAR,:AT,:TILDE,:HASH,:T59,:T60
                    alt38 = 4
                when :DOUBLE_QUOTES
                    alt38 = 5
            end
            case alt38
                when 1
                    # 270:13: IDENTIFIER
                    match(:IDENTIFIER)
                when 2
                    # 270:26: NUMBER
                    match(:NUMBER)
                when 3
                    # 270:35: expression_operator
                    expression_operator()

                when 4
                    # 270:57: quoted_operator
                    quoted_operator()

                when 5
                    # 270:75: '\"'
                    match(:DOUBLE_QUOTES)
                else
                    break
            end
        end
        match(:SINGLE_QUOTES)



    end

    # 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );
    def assign_operator()



        # 274:5: ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' )
        alt39 = 12
        # 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );
        case look_ahead(1)
            when :EQUAL
                alt39 = 1
            when :PLUS
                alt39 = 2
            when :MINUS
                alt39 = 3
            when :TIMES
                alt39 = 4
            when :SLASH
                alt39 = 5
            when :ECOMMERCIAL
                alt39 = 6
            when :PIPE
                alt39 = 7
            when :WEDGE
                alt39 = 8
            when :MODULUS
                alt39 = 9
            when :LEFT_ANGULAR_BRACKET
                alt39 = 10
            when :RIGHT_ANGULAR_BRACKET
                # 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );
                look_ahead39_11 = look_ahead(2)
                if look_ahead39_11 == :RIGHT_ANGULAR_BRACKET  
                    # 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );
                    look_ahead39_12 = look_ahead(3)
                    if look_ahead39_12 == :EQUAL  
                        alt39 = 12
                    elsif look_ahead39_12 == :RIGHT_ANGULAR_BRACKET  
                        alt39 = 11
                    else
                        raise "Expected: 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );"
                    end
                else
                    raise "Expected: 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );"
                end
            else
                raise "Expected: 273:1: assign_operator : ( '=' | '+' '=' | '-' '=' | '*' '=' | '/' '=' | '&' '=' | '|' '=' | '^' '=' | '%' '=' | '<' '<' '=' | '>' '>' '>' '=' | '>' '>' '=' );"

        end
        case alt39
            when 1
                # 274:9: '='
                match(:EQUAL)
            when 2
                # 275:9: '+' '='
                match(:PLUS)
                match(:EQUAL)
            when 3
                # 276:9: '-' '='
                match(:MINUS)
                match(:EQUAL)
            when 4
                # 277:9: '*' '='
                match(:TIMES)
                match(:EQUAL)
            when 5
                # 278:9: '/' '='
                match(:SLASH)
                match(:EQUAL)
            when 6
                # 279:9: '&' '='
                match(:ECOMMERCIAL)
                match(:EQUAL)
            when 7
                # 280:9: '|' '='
                match(:PIPE)
                match(:EQUAL)
            when 8
                # 281:9: '^' '='
                match(:WEDGE)
                match(:EQUAL)
            when 9
                # 282:9: '%' '='
                match(:MODULUS)
                match(:EQUAL)
            when 10
                # 283:9: '<' '<' '='
                match(:LEFT_ANGULAR_BRACKET)
                match(:LEFT_ANGULAR_BRACKET)
                match(:EQUAL)
            when 11
                # 284:9: '>' '>' '>' '='
                match(:RIGHT_ANGULAR_BRACKET)
                match(:RIGHT_ANGULAR_BRACKET)
                match(:RIGHT_ANGULAR_BRACKET)
                match(:EQUAL)
            when 12
                # 285:9: '>' '>' '='
                match(:RIGHT_ANGULAR_BRACKET)
                match(:RIGHT_ANGULAR_BRACKET)
                match(:EQUAL)
        end



    end

    # 288:1: expression_operator : ( '+' | '-' | '*' | '/' | '%' | '=' | '?' | ':' | '&' | '|' | '^' | '>' | '<' | '!' | '.' | '[' | ']' );
    def expression_operator()



        # 
        if (TOKENS[look_ahead(1)] >= 25 && TOKENS[look_ahead(1)] <= 26) || look_ahead(1) == :ECOMMERCIAL || look_ahead(1) == :EQUAL || (TOKENS[look_ahead(1)] >= 34 && TOKENS[look_ahead(1)] <= 46)
            match()
        else
            raise "Expected set"
        end



    end

    # 294:1: quoted_operator : ( '(' | ')' | '{' | '}' | '\\\\' | ';' | ',' | '~' | '@' | '#' | '$' | '\\\\\"' | '\\\\\\'' );
    def quoted_operator()



        # 
        if look_ahead(1) == :SEMICOLON || look_ahead(1) == :COMMA || (TOKENS[look_ahead(1)] >= 29 && TOKENS[look_ahead(1)] <= 30) || (TOKENS[look_ahead(1)] >= 32 && TOKENS[look_ahead(1)] <= 33) || look_ahead(1) == :BACKSLASH || (TOKENS[look_ahead(1)] >= 51 && TOKENS[look_ahead(1)] <= 54) || (TOKENS[look_ahead(1)] >= 59 && TOKENS[look_ahead(1)] <= 60)
            match()
        else
            raise "Expected set"
        end



    end

    # 299:1: parameters[method] : '(' ( parameter_definition[method] )? ')' ;
    def parameters(method)



        # 300:7: '(' ( parameter_definition[method] )? ')'
        match(:LEFT_PARENTESIS)
        # 301:7: ( parameter_definition[method] )?
        alt40 = 2
        # 301:7: ( parameter_definition[method] )?
        look_ahead40_0 = look_ahead(1)

        if look_ahead40_0 == :IDENTIFIER || look_ahead40_0 == :FINAL || look_ahead40_0 == :ANNOTATION  
            alt40 = 1
        end
        case alt40
            when 1
                # 301:8: parameter_definition[method]
                parameter_definition(method)

        end
        match(:RIGHT_PARENTESIS)



    end

    # 305:1: parameter_definition[method] : variable_modifier type[parameter] IDENTIFIER ;
    def parameter_definition(method)
    	_IDENTIFIER15 = nil




    	    parameter = ParameterDefinition.new


        # 310:5: variable_modifier type[parameter] IDENTIFIER
        variable_modifier()

        type(parameter)

        _IDENTIFIER15 = @input.look_ahead(1)
        match(:IDENTIFIER)

                parameter.name = _IDENTIFIER15.text
                method.add_parameter(parameter)
            



    end

    # 316:1: type[member] : type_name[member] ( array_brackets[member] )* ;
    def type(member)



        # 317:7: type_name[member] ( array_brackets[member] )*
        type_name(member)

        # 317:25: ( array_brackets[member] )*
        while true
            alt41 = 2
            # ()* loopback of 317:25: ( array_brackets[member] )*
            look_ahead41_0 = look_ahead(1)
            if look_ahead41_0 == :LEFT_SQUARE_BRACKET  
                alt41 = 1
            end
            case alt41
                when 1
                    # 317:26: array_brackets[member]
                    array_brackets(member)

                else
                    break
            end
        end



    end

    # 320:1: type_name[member] : ( IDENTIFIER ) ( package_descriptors[member] )* ( type_argument[member] )? ;
    def type_name(member)
    	_IDENTIFIER16 = nil




        # 321:7: ( IDENTIFIER ) ( package_descriptors[member] )* ( type_argument[member] )?
        # 321:8: IDENTIFIER
        _IDENTIFIER16 = @input.look_ahead(1)
        match(:IDENTIFIER)
         member.type = _IDENTIFIER16.text 
        # 322:7: ( package_descriptors[member] )*
        while true
            alt42 = 2
            # ()* loopback of 322:7: ( package_descriptors[member] )*
            look_ahead42_0 = look_ahead(1)
            if look_ahead42_0 == :DOT  
                alt42 = 1
            end
            case alt42
                when 1
                    # 322:9: package_descriptors[member]
                    package_descriptors(member)

                else
                    break
            end
        end
        # 323:7: ( type_argument[member] )?
        alt43 = 2
        # 323:7: ( type_argument[member] )?
        look_ahead43_0 = look_ahead(1)

        if look_ahead43_0 == :LEFT_ANGULAR_BRACKET  
            alt43 = 1
        end
        case alt43
            when 1
                # 323:9: type_argument[member]
                type_argument(member)

        end



    end

    # 326:1: package_descriptors[member] : '.' IDENTIFIER ;
    def package_descriptors(member)
    	_IDENTIFIER17 = nil




        # 327:7: '.' IDENTIFIER
        match(:DOT)
        _IDENTIFIER17 = @input.look_ahead(1)
        match(:IDENTIFIER)
         member.type += ".#{_IDENTIFIER17.text}" 



    end

    # 330:1: type_argument[member] : '<' ( member_special_identifier[member] )* '>' ;
    def type_argument(member)



        # 331:7: '<' ( member_special_identifier[member] )* '>'
        match(:LEFT_ANGULAR_BRACKET)
         member.type += '<' 
        # 332:7: ( member_special_identifier[member] )*
        while true
            alt44 = 2
            alt44 = DFA44.predict(self, @input)
            case alt44
                when 1
                    # 332:9: member_special_identifier[member]
                    member_special_identifier(member)

                else
                    break
            end
        end
        match(:RIGHT_ANGULAR_BRACKET)
         member.type += '>' 



    end

    # 336:1: array_brackets[member] : '[' ']' ;
    def array_brackets(member)



        # 337:7: '[' ']'
        match(:LEFT_SQUARE_BRACKET)
        match(:RIGHT_SQUARE_BRACKET)
         member.type += '[]' 



    end

    # 340:1: modifier[member] : ( PRIVATE | PUBLIC | PROTECTED | STATIC | ABSTRACT | FINAL | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP )* ;
    def modifier(member)



        # 342:5: ( PRIVATE | PUBLIC | PROTECTED | STATIC | ABSTRACT | FINAL | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP )*
        # 342:5: ( PRIVATE | PUBLIC | PROTECTED | STATIC | ABSTRACT | FINAL | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP )*
        while true
            alt45 = 12
            # ()* loopback of 342:5: ( PRIVATE | PUBLIC | PROTECTED | STATIC | ABSTRACT | FINAL | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP )*
            case look_ahead(1)
                when :PRIVATE
                    alt45 = 1
                when :PUBLIC
                    alt45 = 2
                when :PROTECTED
                    alt45 = 3
                when :STATIC
                    alt45 = 4
                when :ABSTRACT
                    alt45 = 5
                when :FINAL
                    alt45 = 6
                when :NATIVE
                    alt45 = 7
                when :SYNCHRONIZED
                    alt45 = 8
                when :TRANSIENT
                    alt45 = 9
                when :VOLATILE
                    alt45 = 10
                when :STRICTFP
                    alt45 = 11
            end
            case alt45
                when 1
                    # 342:7: PRIVATE
                    match(:PRIVATE)
                     member.add_modifier('private')      
                when 2
                    # 343:7: PUBLIC
                    match(:PUBLIC)
                     member.add_modifier('public')       
                when 3
                    # 344:7: PROTECTED
                    match(:PROTECTED)
                     member.add_modifier('protected')    
                when 4
                    # 345:7: STATIC
                    match(:STATIC)
                     member.add_modifier('static')       
                when 5
                    # 346:7: ABSTRACT
                    match(:ABSTRACT)
                     member.add_modifier('abstract')     
                when 6
                    # 347:7: FINAL
                    match(:FINAL)
                     member.add_modifier('final')        
                when 7
                    # 348:7: NATIVE
                    match(:NATIVE)
                     member.add_modifier('native')       
                when 8
                    # 349:7: SYNCHRONIZED
                    match(:SYNCHRONIZED)
                     member.add_modifier('synchronized') 
                when 9
                    # 350:7: TRANSIENT
                    match(:TRANSIENT)
                     member.add_modifier('transient')    
                when 10
                    # 351:7: VOLATILE
                    match(:VOLATILE)
                     member.add_modifier('volatile')     
                when 11
                    # 352:7: STRICTFP
                    match(:STRICTFP)
                     member.add_modifier('strictfp')     
                else
                    break
            end
        end



    end

    # 356:1: variable_modifier : ( FINAL | ANNOTATION )* ;
    def variable_modifier()



        # 357:7: ( FINAL | ANNOTATION )*
        # 357:7: ( FINAL | ANNOTATION )*
        while true
            alt46 = 2
            # ()* loopback of 357:7: ( FINAL | ANNOTATION )*
            look_ahead46_0 = look_ahead(1)
            if look_ahead46_0 == :FINAL || look_ahead46_0 == :ANNOTATION  
                alt46 = 1
            end
            case alt46
                when 1
                    # 
                    if look_ahead(1) == :FINAL || look_ahead(1) == :ANNOTATION
                        match()
                    else
                        raise "Expected set"
                    end
                else
                    break
            end
        end



    end

    # 362:1: member_special_identifier[member] : ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS | '?' );
    def member_special_identifier(member)
    	_IDENTIFIER18 = nil
    	_EXTENDS19 = nil




        # 363:5: ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS | '?' )
        alt47 = 7
        # 362:1: member_special_identifier[member] : ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS | '?' );
        case look_ahead(1)
            when :IDENTIFIER
                alt47 = 1
            when :COMMA
                alt47 = 2
            when :ECOMMERCIAL
                alt47 = 3
            when :LEFT_ANGULAR_BRACKET
                alt47 = 4
            when :RIGHT_ANGULAR_BRACKET
                alt47 = 5
            when :EXTENDS
                alt47 = 6
            when :QUESTION_MARK
                alt47 = 7
            else
                raise "Expected: 362:1: member_special_identifier[member] : ( IDENTIFIER | ',' | '&' | '<' | '>' | EXTENDS | '?' );"

        end
        case alt47
            when 1
                # 363:7: IDENTIFIER
                _IDENTIFIER18 = @input.look_ahead(1)
                match(:IDENTIFIER)
                 member.type += _IDENTIFIER18.text
            when 2
                # 364:7: ','
                match(:COMMA)
                 member.type += ", "
            when 3
                # 365:7: '&'
                match(:ECOMMERCIAL)
                 member.type += " & "
            when 4
                # 366:7: '<'
                match(:LEFT_ANGULAR_BRACKET)
                 member.type += '<'
            when 5
                # 367:7: '>'
                match(:RIGHT_ANGULAR_BRACKET)
                 member.type += '>'
            when 6
                # 368:7: EXTENDS
                _EXTENDS19 = @input.look_ahead(1)
                match(:EXTENDS)
                 member.type += " #{_EXTENDS19.text} "
            when 7
                # 369:7: '?'
                match(:QUESTION_MARK)
                 member.type += '?' 
        end



    end


    private

    class TokenStream
        attr_reader :index

        def initialize(input)
            @buffer = []
            @input = input
            @channel = nil

            @index = 0;
        end

        # returns a Token
        def look_ahead(pos)
            offset = @index + pos - 1

            while @buffer[-1] != :EOF && @buffer.length < offset + 1
                token = @input.next_token
                if token == :EOF || token.channel == @channel
                    @buffer << token
                end
            end

            offset = -1 if offset >= @buffer.length
            if offset < @buffer.length
                @buffer[offset]
            end
        end

        def mark
            @state = { :index => @index }
            return 0
        end

        def rewind(marker)
            @index = @state[:index]
        end

        def consume
           look_ahead(1) # force a read from the input if necessary
           @index = @index + 1
        end
    end

    def match(token = nil)
        if token.nil? || look_ahead(1) == token
            @input.consume
            @failed = false
            return
        elsif @backtracking > 0
            @failed = true
        else
            raise "Expected #{token}"
        end
    end

    def look_ahead(k)
        token = @input.look_ahead(k)
        if token != :EOF
            token = token.token_type
        end

        token
    end


	    class DFA
	        def initialize(eot, eof, min, max, accept, special, transition)
	            @eot = eot
	            @eof = eof
	            @min = min
	            @max = max
	            @accept = accept
	            @special = special
	            @transition = transition
	        end

	        def predict(parser, input)
	            mark = input.mark()
	            s = 0 # we always start at s0
	            begin
	                loop do
	                    special_state = @special[s]
	                    if special_state >= 0
	                        s = parser.special_state_transition(special_state)
	                        input.consume()
	                        next
	                    end

	                    if @accept[s] >= 1
	                        return @accept[s]
	                    end

	                    # look for a normal char transition
	                    c = input.look_ahead(1).to_i
	                    if c != :EOF && c >= @min[s] && c <= @max[s]
	                        next_state = @transition[s][c - @min[s]] # move to next state
	                        if next_state < 0
	                            # was in range but not a normal transition
	                            # must check EOT, which is like the else clause.
	                            # eot[s]>=0 indicates that an EOT edge goes to another
	                            # state.
	                            if @eot[s] >= 0  # EOT Transition to accept state?
	                                s = @eot[s]
	                                input.consume()
	                                next
	                            end
	                            raise "No viable alt"
	                        end
	                        s = next_state
	                        input.consume()
	                        next
	                    end
	                    if @eot[s] >= 0   # EOT Transition?
	                        s = @eot[s]
	                        input.consume()
	                        next
	                    end
	                    if c == :EOF && @eof[s] >= 0   # EOF Transition to accept state?
	                        return @accept[@eof[s]]
	                    end

	                    # not in range and not EOF/EOT, must be invalid symbol
	                    raise "No viable alt"
	                end
	            ensure
	                input.rewind(mark)
	            end
	        end
	    end

    DFA9 = DFA.new(
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,36,24,0,5,5,5,5,5,5,5,5,5,0,5,5,5],
        [20,20,20,20,20,20,20,20,20,20,20,20,35,5,37,36,35,0,35,37,37,37,
         37,37,37,37,35,0,37,37,37],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,1,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [12,-1,-1,-1,-1,1,2,3,4,5,6,7,8,9,10,11],
            [16,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 14,-1,-1,-1,-1,-1,-1,17,-1,13,15],
            [18],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [26],
            [27,-1,-1,27,-1,-1,-1,27,17,-1,-1,27],
            [],
            [16,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 14,-1,-1,-1,-1,-1,-1,-1,-1,13,15],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [28,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,15,-1,25],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [16,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15],
            [],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,27,
                 22,23,29,21,-1,-1,27,17,-1,-1,27,-1,25],
            [30,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 22,23,20,21,-1,-1,-1,-1,-1,-1,-1,-1,25],
            [19,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,27,
                 22,23,29,21,-1,-1,27,-1,-1,-1,27,-1,25]
        ])

    def special_state_transition(s)
    		-1
    end

    public :special_state_transition
    DFA18 = DFA.new(
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [5,0,5,0,34,5,5,0,0,5,5,5,25],
        [58,0,46,0,34,5,37,0,0,5,35,37,46],
        [-1,1,-1,2,-1,-1,-1,3,4,-1,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [
            [2,-1,-1,-1,3,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4],
            [],
            [1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 6,7,-1,7,-1,-1,7,8,-1,5,1,-1,-1,7,7,7,7,-1,7,7,-1,7],
            [],
            [9],
            [10],
            [1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,
                 1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1],
            [],
            [],
            [12],
            [1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 1,-1,-1,-1,-1,-1,-1,8,-1,5,1],
            [1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,
                 1,1,1,-1,-1,7,-1,-1,-1,-1,-1,1],
            [7,7,-1,7,-1,-1,7,8,-1,8,-1,-1,-1,7,7,7,7,-1,7,7,-1,7]
        ])

    def special_state_transition(s)
    		-1
    end

    public :special_state_transition
    DFA44 = DFA.new(
        [-1,-1,-1,-1,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1],
        [5,5,0,0,5,5,5],
        [37,37,0,0,37,37,37],
        [-1,-1,1,2,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1],
        [
            [2,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,
                 1,2,2,-1,-1,-1,-1,-1,-1,-1,-1,2],
            [4,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,
                 2,2,2,-1,-1,-1,-1,-1,-1,3,-1,2],
            [],
            [],
            [2,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,
                 2,5,2,-1,-1,3,3,3,-1,3,-1,2],
            [6,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,
                 2,2,2,-1,-1,-1,-1,-1,-1,-1,-1,2],
            [2,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,
                 2,5,2,-1,-1,3,-1,-1,-1,3,-1,2]
        ])

    def special_state_transition(s)
    		-1
    end

    public :special_state_transition
end